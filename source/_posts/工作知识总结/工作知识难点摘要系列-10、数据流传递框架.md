---
title: 十、数据流传递框架
tags: 工作知识总结
categories: 热爱我的工作
comments: true
---

# 一、数据流传递框架

## 1、简单介绍
<p>&emsp;&emsp;先说一下为啥写这个都咚咚，主要是想了解一下在开发一个完整模块的时候怎么实现数据的收集，上传，逐层传递后的渲染，帮助自己理解整个模块的开发。偷偷学习了组内大佬的开发思路，不能被露哥发现喽，偷学。。。哈哈哈哈！！！感谢露哥，感谢露哥，感谢露哥，嘿嘿嘿！！！</p>

## 2、基本框架
<p>&emsp;&emsp;首先，我们来看一下整体的HTML的结构，父组件套子组件，子组件再套子组件，那我们我们的数据是在第一层组件请求来的，所以我们的数据是要传递下去的，这里比较重要的就是我们的第二层组件和第三层组件都是根据数据来渲染的，并且组件基本上都是用v-model绑定数据，这样我们在做一下操作的时候就会动态将绑定的数据更改，最后传回到外层组件，也就是我们的收集数据。那来简单的看一下HTML结构吧，比如我们要展示单词的信息，并且可以手动修改。</p>

## 2.1、第一层
<p>&emsp;&emsp;先来看第一层，第一层很简单，引入一个子组件，子组件绑定一个id。</p>

```javascript
<template>
  <div class="first-container">
    <Button @click="getDcId">点击修改单词ID</Button>
    <EditDrawer :id="currentId"></EditDrawer>
  </div>
</template>
<script lang="ts">
import { Vue, Component } from 'vue-property-decorator';

@Component({
  components: {
    EditDrawer: () => import('./EditDrawer.vue')
  }
})
export default class TestCase extends Vue {

  currentId:string = '';

  //当点击按钮的时候，我们改变currentId的值，这个值会传到子组件的
  public getDcId() {
    this.currentId = 'abandon';
  }
}
<script>
```

## 2.2、第二层
<p>&emsp;&emsp;然后我们来看第一层的子组件(EditDrawer.vue)，也就是我们的第二层，我们在第二层以id作为参数调用接口请求该单词的所有信息。这一层很重要，我们在这一层拿到请求数据并且把数据传下去了（利用dcInfo字段），同时也在这一层做了收集数据的最后一步，收集到所有的数据（用的Save方法）。</p>

```javascript
<template>
  <div class="next-container">
    <div class="other-operate">
      /* 在这里你可以写一些其他的东西嘛，就是不要觉局限于一个页面就引入一个组件 */
    </div>
    <Button @click="Save()">点击修改单词ID</Button>
    <div class="main-container">
      /* 在这里，我们把数据传下去了，层层往下传就好了 */
      <ProEdit :dataInfo="dcInfo" ref="proEdit"></ProEdit>
    </div>
  </div>
</template>
<script lang="ts">
import { Vue, Component, Prop, Watch } from 'vue-property-decorator';
//调用接口
import { getDcDetail } from '@/http/api/http.ts';

@Component({
  components: {
    ProEdit: () => import('./PropertyManage/index.vue')
  }
})
export default class TestCase extends Vue {

  dcInfo:any = {};

  //接受id
  @Prop({
    type: String,
    default: ''
  })
  id: string;

  //监听id，一旦传入id,就请求数据
  @Watch('id',{
    deep: true,
    immediate: true
  })
  public getIdMessage(val) {
    if(val) {
      this.getDcInfo();
    }
  }

  public async getDcInfo():Promise<any> {
    const res = await getDcDetail({
      id:this.id;
    })
    if(res) {
      //实际情况下肯定不会这么简单了，是要对请求过来的数据做对应处理的，知道就好
      this.dcInfo = res;
    }
  }

  //可以看到我们用了$refs访问了子组件的方法收集了所有的数据，然后调用了接口，把数据传给了后端
  public Save() {
    const data = (this.$refs.proEdit as any).getData();
    const res = await saveDc(data);
    if (res) {
      this.$Message.success('暂存成功！');
    }
  }
}
<script>
```

## 2.3、第三层
<p>&emsp;&emsp;然后我们来看第三层，这一层主要是把信息散发出去，因为数据是分为好几个小模块的，会在代码里写，大家注意看数据的结构，我们把数据分发下去。并且这个组件里有个getData方法收集数据，还记得我们在第二层里用的save方法就是在调用这个getData么</p>

<p>&emsp;&emsp;这里用的component动态生成组件，我的其他文章（工作知识难点系列）里有解释，看不懂的小伙伴可以去看一下。</p>

<p>&emsp;&emsp;这里的dataInfo就是数据的主体，它有三个部分，每个部分有对应的数据去渲染一个component组件，并且在component组件里，利用v-model绑定了数据的每一部分，这样改变数据的时候我们就可以直接双向绑定，改变的数据会直接传到这一层，所以我们只要改数据，这一层的dataInfon拿到的永远都是更新的数据。</p>

```javascript
<template>
  <div class="last-container">
    <div class="module-container">
      <div v-for="(item, index) in moduleArr" :key="index">
        <component :is="item.code" :data="dataInfo[item.code]" :ref="item.code" :id="dataInfo.baseInfo.id"></component>
      </div>
    </div>
  </div>
</template>
<script lang="ts">
import { Vue, Component, Prop, Watch } from 'vue-property-decorator';

@Component({
  components: {
    FirstSection: () => import('./FirstSection.vue'),
    SecondSection: () => import('./SecondSection.vue'),
    ThirdSection: () => import('./ThirdSection.vue')
  }
})
export default class TestCase extends Vue {

//通过传值拿到dataInfo,组件会根据dataInfo去渲染
  @Prop({
    type: Object,
    default: () => {
      return {}
    }
  })
  dataInfo: any;

  //通过循环moduleArr实现三个部分的分别渲染，每一部分引入自己对应的信息
  public moduleArr: Array<{
    name: string;
    code: string;
  }> = [{
    name: '第一部分信息',
    code: 'FirstSection',
  }, {
    name: '第二部分信息',
    code: 'SecondSection',
  }, {
    name: '第三部分信息',
    code: 'ThirdSection',
  }];

  public getData () {
    //正常这里是要做一些数据处理的，更具具体情况做不同的事情，大家心里有数就好我这里就
    //直接返回数据了，应为这个dataInfo就是最新的数据
    return dataInfo;
  }

  /* 为了防止大家看不懂，我把数据模拟结构写一下，简单模拟，别太当真
  const dataInfo = {
    FirstSection: {
      name: '我是第一部分',
      content: '我是第一部分的内容'
    },
    SecondSection: {
      name: '我是第一部分',
      content: '我是第一部分的内容'
    },
    ThirdSection: {
      name: '我是第一部分',
      content: '我是第一部分的内容'
    }
  } */
}
<script>
```

## 2.4、第四层
<p>&emsp;&emsp;为了大家，能够理解为啥上一层的dataInfo是一直更新的，并且更了解结构，我写了第四层，就拿数据的第一部分为例吧。我们直接用v-modal绑定的data的两个字段，这样在改变input输入框的值的时候，结果会直接改变data的值，并且会把data传到上一层的dataInfo，这样上一层的dataInfo就是一直都是最新的，所以在第二层点击保存的时候，用了第三层的方法，直接返回dataInfo是可以的。</p>

```javascript
<template>
  <div class="last-last-container">
    <Input type="text" v-model="data.name" clearable />
    <Input type="text" v-model="data.content" clearable />
  </div>
</template>
<script lang="ts">
import { Vue, Component, Prop, Watch } from 'vue-property-decorator';

@Component({
  components: {
  }
})
export default class TestCase extends Vue {

  //这里我们接收了上一层的dataInfo的第一部分信息
  @Prop({
    type: Object,
    default: () => {
      return {}
    }
  })
  data: any;
}
<script>
```


<p>&emsp;&emsp;写完啦，好累呀。。。。最后感谢露哥！！！！露哥也听不见。。。。。。</p>
